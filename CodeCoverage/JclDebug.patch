Index: JclDebug.pas
===================================================================
--- JclDebug.pas	(revision 3256)
+++ JclDebug.pas	(working copy)
@@ -209,8 +209,14 @@
     Segment: Word;
     VA: DWORD; // VA relative to (module base address + $10000)
     LineNumber: Integer;
+    UnitName : PJclMapString;
   end;
 
+  TJclUnitRecord = record
+     UnitName : PJclMapString;
+     UnitFileName : PJclMapString;
+  end;
+
   TJclMapScanner = class(TJclAbstractMapParser)
   private
     FSegmentClasses: array of TJclMapSegmentClass;
@@ -218,9 +224,12 @@
     FProcNames: array of TJclMapProcName;
     FSegments: array of TJclMapSegment;
     FSourceNames: array of TJclMapProcName;
+    FUnitDetails : array of TJclUnitRecord;
     FLineNumbersCnt: Integer;
     FLineNumberErrors: Integer;
     FNewUnitFileName: PJclMapString;
+    FNewUnitName: PJclMapString;
+    FCurrentUnitName : PJclMapString;
     FProcNamesCnt: Integer;
     FSegmentCnt: Integer;
   protected
@@ -232,17 +241,28 @@
     procedure LineNumbersItem(LineNumber: Integer; const Address: TJclMapAddress); override;
     procedure LineNumberUnitItem(UnitName, UnitFileName: PJclMapString); override;
     procedure Scan;
+    function GetLineNumberByIndex(Index:Integer):TJCLMapLineNumber;
+    function GetLineNumberCount():Integer;
+    function GetSegmentByIndex(Index : Integer):TJCLMapSegment;
+    function GetSegmentCount:Integer;
   public
     constructor Create(const MapFileName: TFileName; Module: HMODULE); override;
     // Addr are virtual addresses relative to (module base address + $10000)
     function LineNumberFromAddr(Addr: DWORD): Integer; overload;
     function LineNumberFromAddr(Addr: DWORD; out Offset: Integer): Integer; overload;
+    function SegmentFromAddr(Addr: DWORD):TJclMapSegment;
+    function FileNameFromUnitName(UnitName : String):String;
     function ModuleNameFromAddr(Addr: DWORD): string;
     function ModuleStartFromAddr(Addr: DWORD): DWORD;
     function ProcNameFromAddr(Addr: DWORD): string; overload;
     function ProcNameFromAddr(Addr: DWORD; out Offset: Integer): string; overload;
     function SourceNameFromAddr(Addr: DWORD): string;
     property LineNumberErrors: Integer read FLineNumberErrors;
+    property LineNumberCount:Integer read GetLineNumberCount;
+    property LineNumberByIndex[index : integer]:TJclMapLineNumber read GetLineNumberByIndex;
+    property SegmentCount : Integer read GetSegmentCount;
+    property SegmentByIndex[index : integer]:TJclMapSegment read GetSegmentByIndex;
+
   end;
 
 type
@@ -1663,7 +1683,10 @@
   //                     only one segment of code
   // after Delphi 2005: segments started at code base address (module base address + $10000)
   //                    2 segments of code
-  if (Length(FSegmentClasses) > 0) and (FSegmentClasses[0].Start > 0) and (Addr > FSegmentClasses[0].Start) then
+
+  // Bug fix 2010-06-23 Christer Fahlgren, for system segment which starts with 0
+  // Addr can be equal to FSegmentClasses[0].Start, thus changing to >=
+  if (Length(FSegmentClasses) > 0) and (FSegmentClasses[0].Start > 0) and (Addr >= FSegmentClasses[0].Start) then
     // Delphi 2005 and later
     // The first segment should be code starting at module base address + $10000
     Result := Addr - FSegmentClasses[0].Start
@@ -1756,16 +1779,17 @@
     FLineNumbers[FLineNumbersCnt].Segment := FSegmentClasses[SegIndex].Segment;
     FLineNumbers[FLineNumbersCnt].VA := VA;
     FLineNumbers[FLineNumbersCnt].LineNumber := LineNumber;
+    FLineNumbers[FLineNumbersCnt].UnitName :=  FCurrentUnitName;
     Inc(FLineNumbersCnt);
     Added := True;
-    if FNewUnitFileName <> nil then
+    if FNewUnitName <> nil then
     begin
       C := Length(FSourceNames);
       SetLength(FSourceNames, C + 1);
       FSourceNames[C].Segment := FSegmentClasses[SegIndex].Segment;
       FSourceNames[C].VA := VA;
-      FSourceNames[C].ProcName := FNewUnitFileName;
-      FNewUnitFileName := nil;
+      FSourceNames[C].ProcName := FNewUnitName;
+      FNewUnitName := nil;
     end;
     Break;
   end;
@@ -1774,10 +1798,38 @@
 end;
 
 procedure TJclMapScanner.LineNumberUnitItem(UnitName, UnitFileName: PJclMapString);
+var
+  C:Integer;
 begin
   FNewUnitFileName := UnitFileName;
+  FNewUnitName := UnitName;
+  FCurrentUnitName := UnitName;
+  C := Length(FUnitDetails);
+  SetLength(FUnitDetails, C + 1);
+  FUnitDetails[C].UnitName := UnitName;
+  FUnitDetails[C].UnitFileName := UnitFileName;
 end;
 
+function TJclMapScanner.GetLineNumberByIndex(Index:Integer):TJCLMapLineNumber;
+begin
+  result := FLineNumbers[Index];
+end;
+
+function TJclMapScanner.GetLineNumberCount():Integer;
+begin
+  result := FLineNumbersCnt;
+end;
+
+function TJclMapScanner.GetSegmentByIndex(Index:Integer):TJCLMapSegment;
+begin
+  result := FSegments[Index];
+end;
+
+function TJclMapScanner.GetSegmentCount():Integer;
+begin
+  result := FSegmentCnt;
+end;
+
 function TJclMapScanner.ModuleNameFromAddr(Addr: DWORD): string;
 var
   I: Integer;
@@ -1791,6 +1843,36 @@
     end;
 end;
 
+function TJclMapScanner.SegmentFromAddr(Addr: DWORD): TJclMapSegment;
+var
+  I: Integer;
+begin
+
+  for I := Length(FSegments) - 1 downto 0 do
+    if (FSegments[I].StartVA <= Addr) and (Addr < FSegments[I].EndVA) then
+    begin
+      Result := FSegments[I];
+      Break;
+    end;
+end;
+
+function TJclMapScanner.FileNameFromUnitName(UnitName : String): String;
+var
+  I: Integer;
+  tmpUnitName : String;
+begin
+  for I := 0 to Length(FUnitDetails) - 1 do
+  begin
+    tmpUnitName := LowerCase(MapStringToStr(FUnitDetails[I].UnitName));
+    if (tmpUnitName=LowerCase(UnitName)) then
+    begin
+      result := MapStringToStr(FUnitDetails[I].UnitFileName);
+      break;
+    end;
+  end;
+end;
+
+
 function TJclMapScanner.ModuleStartFromAddr(Addr: DWORD): DWORD;
 var
   I: Integer;
